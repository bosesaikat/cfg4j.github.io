---
title: "usage"
bg: darkgray
color: orange
fa-icon: check-square
---

# Quick start
-------------------------
0. Add **cfg4j-core** and **cfg4j-git** dependencies to your project (see previous paragraph for detail).

1. Use the following code in your application to connect to the sample configuration source (git repository).
Also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-bind).
{% highlight java linenos=table %}
public class Cfg4jPoweredApplication {

  // "Reksio" is a friendly dog that has many friends
  public interface ReksioConfig {  
    List<String> friends();  
  }

  public static void main(String... args) {
  
    // Select our sample git repository as the configuration source
    ConfigurationSource source = new GitConfigurationSourceBuilder()
          .withRepositoryURI("https://github.com/cfg4j/cfg4j-git-sample-config.git")
          .build();
          
    // Create configuration provider backed by the source
    ConfigurationProvider provider = new ConfigurationProviderBuilder()
          .withConfigurationSource(source)
          .withReloadStrategy(new PeriodicalReloadStrategy(5, TimeUnit.SECONDS))
          .build();
    
    // Get info about our dog. When you add more friends in the configuration file, object below will automatically reflect that change (by mutating friends() list).
    ReksioConfig reksioConfig = configurationProvider.bind("reksio", ReksioConfig.class);
    
    // Display friends of Reksio!
    System.out.println(reksioConfig.friends());
  }

}
{% endhighlight %}

* Optional steps
    1. Fork the [sample configuration repository](https://github.com/cfg4j/cfg4j-git-sample-config).
    2. Add your configuration to the "*application.properties*" file and commit the changes.
    3. Update the code above to point to your fork.


-------------------------

# Tutorial
-------------------------

### Introduction
Using cfg4j is quite simple. It boils down to the following steps:

1. Point to the ```ConfigurationSource``` that stores your configs (e.g. Consul K-V store, git repository, local files, classpath resources).
2. Create ```ConfigurationProvider``` backed by your configuration source.
3. Access your configuration in one of the two ways:
    1. Directly through ConfigurationProvider methods (e.g. ```getProperty("my.property", Integer.class)```)
    2. Through a binding mechanism. Simply create an interface with methods representing your configuration variables
       and ask ConfigurationProvider to create a configuration object implementing your interface
       (i.e. calling ```bind("my.configuration.set", MyInterface.class)```). Every time the configuration changes
       your object will be automatically updated with new values.
4. (optional) If you want you can customize the ConfigurationProvider behavior by using:
    * ```ReloadStrategy``` - those allow configuration to be automatically reloaded. There's ```PeriodicalReloadStrategy``` provided
        that can reload configuration after every specified time period. You can also implement your own strategy.
    * ```Environment``` - Use it to specify where your configuration is located inside ConfigurationSource. It's especially useful
        when you have multiple configuration sets (e.g. multi-tenant) in one source (e.g. under different paths, on
        different git branches, etc.). Read more below.

### Configuration source
Obviously, you need your configuration to be stored somewhere before you can access it. You can store it in a K-V store (e.g. Consul K-V),
files (remote git repository, local files, classpath resources) or a relational database. If you're unsure what the best practices are,
you can consult [this article]().

Once you have your configuration in place, create a ```ConfigurationSource`` object that will fetch it. Here's an example using Consul K-V.

{% highlight java linenos=table %}
ConfigurationSource source = new ConsulConfigurationSourceBuilder().build();
{% endhighlight %}

To learn more about supported configuration sources and their capabilities head to the [PLUGINS section](#plugins).

### Configuration provider
Once we have ```ConfigurationSource``` in place, we need ```ConfigurationProvider``` that will provide your app with a uniform interface
for reading configs.

You can obtain ```ConfigurationProvider``` using builder:

{% highlight java linenos=table %}
ConfigurationSource source = ... (see above)
ConfigurationProvider provider = new ConfigurationProviderBuilder().withConfigurationSource(source).build();
{% endhighlight %}

You can also use DI container (like Spring)
{% highlight java linenos=table %}
@Bean
public ConfigurationProvider configurationProvider(ConfigurationSource source) {
  return new ConfigurationProviderBuilder().withConfigurationSource(source).build();
}
{% endhighlight %}

### Reading configuration
Once you obtain ```ConfigurationProvider``` you can use it for accessing configuration:

* Get primitive (and boxed) types directly from Provider (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-simple)).
{% highlight java linenos=table %}
// some.property=false
Boolean property = provider.getProperty("some.property", Boolean.class);

// some.other.property=1234
Integer property = provider.getProperty("some.other.property", Integer.class);

// my.floatsArray=1.2,99.999,0.15
float[] floats = provider.getProperty("my.floatsArray", float[].class);

// my.url=http://www.cfg4j.org
URL url = provider.getProperty("my.url", URL.class);
{% endhighlight %}

* Get collections directly from Provider
{% highlight java linenos=table %}
// some.string.list=jak,sie,masz
List<String> stringList = provider.getProperty("some.string.list", new GenericType<List<String>>() {});

// some.map=a=1,b=33,c=-10
Map<String, Integer> pairs = provider.getProperty("some.map", new GenericType<Map<String, Integer>>() {});
{% endhighlight %}

* Utilize object binding (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-bind)).
{% highlight java linenos=table %}
// Define your configuration interface
public interface MyConfiguration {
  Boolean featureToggle();
  File[] someFiles();
  Map<String, Integer> prices();
}

// someFeature.featureToggle=true
// someFeature.someFiles=/temp/fileA.txt,/temp/fileB.txt
// someFeature.prices=apple=1,candy=33,car=10
MyConfiguration config = simpleConfigurationProvider.bind("someFeature", MyConfiguration.class);

// Use it (when configuration changes your object will be auto-updated!)
if(config.featureToggle()) {
  ...
}

{% endhighlight %}




### Configuration reloading
Being able to update your configuration without bringing the service down is extremely important for web apps. **CFG4J** provides
runtime configuration reloading which can be configured using ```RefreshStrategy```. When configuration gets
reloaded all bound configuration objects (see "Reading configuration" above) will be updated.

* Reload configuration periodically (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-simple)).
{% highlight java linenos=table %}
// Refresh every second
ConfigurationProvider provider = new ConfigurationProviderBuilder()
        .withRefreshStrategy(new PeriodicalRefreshStrategy(1, TimeUnit.SECONDS))
        .build();
{% endhighlight %}

* Refresh on-demand (e.g. triggered by push mechanism)
{% highlight java linenos=table %}
// Implement your strategy
public class MyRefreshStrategy implements RefreshStrategy {

  public void init(Refreshable resource) {
      ...
      resource.refresh();
      ...
  }

  public void shutdown() {
     ...
  }
}

ConfigurationProvider provider = new ConfigurationProviderBuilder()
        .withRefreshStrategy(new MyRefreshStrategy())
        .build();
{% endhighlight %}
