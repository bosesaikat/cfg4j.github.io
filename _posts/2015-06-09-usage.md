---
title: "usage"
bg: darkgray
color: orange
fa-icon: check-square
---

# Quick start
-------------------------

You may want to read [the following (a bit lengthy) article about configuration management using cfg4j](http://potocki.io/post/141230472743/configuration-management-for-distributed-systems)
to get better understanding of the core configuration management concepts.

0. Add **cfg4j-core** and **cfg4j-git** dependencies to your project (see previous paragraph for detail).

1. Use the following code in your application to connect to the sample configuration source (git repository).
Also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-bind).
{% highlight java linenos=table %}
public class Cfg4jPoweredApplication {

  // "Reksio" is a friendly dog that has many friends
  public interface ReksioConfig {  
    List<String> friends();  
  }

  public static void main(String... args) {
  
    // Select our sample git repository as the configuration source
    ConfigurationSource source = new GitConfigurationSourceBuilder()
          .withRepositoryURI("https://github.com/cfg4j/cfg4j-git-sample-config.git")
          .build();
          
    // Create configuration provider backed by the source
    ConfigurationProvider provider = new ConfigurationProviderBuilder()
          .withConfigurationSource(source)
          .withReloadStrategy(new PeriodicalReloadStrategy(5, TimeUnit.SECONDS))
          .build();
    
    // Get info about our dog. When you add more friends in the configuration file, object below will automatically reflect that change (by mutating friends() list).
    ReksioConfig reksioConfig = configurationProvider.bind("reksio", ReksioConfig.class);
    
    // Display friends of Reksio!
    System.out.println(reksioConfig.friends());
  }

}
{% endhighlight %}

* Optional steps
    1. Fork the [sample configuration repository](https://github.com/cfg4j/cfg4j-git-sample-config).
    2. Add your configuration to the "*application.properties*" file and commit the changes.
    3. Update the code above to point to your fork.


-------------------------

# Tutorial
-------------------------

### Introduction
Using cfg4j is quite simple. It boils down to the following steps:

1. Point to the ```ConfigurationSource``` that stores your configs (e.g. Consul K-V store, git repository, local files, classpath resources).
2. Create ```ConfigurationProvider``` backed by your configuration source.
3. Access your configuration in one of the two ways:
    1. Directly through ConfigurationProvider methods (e.g. ```getProperty("my.property", Integer.class)```)
    2. Through a binding mechanism. Simply create an interface with methods representing your configuration variables
       and ask ConfigurationProvider to create a configuration object implementing your interface
       (i.e. calling ```bind("my.configuration.set", MyInterface.class)```). Every time the configuration changes
       your object will be automatically updated with new values.
4. (optional) If you want you can customize the ConfigurationProvider behavior by using:
    * ```ReloadStrategy``` - those allow configuration to be automatically reloaded. There's ```PeriodicalReloadStrategy``` provided
        that can reload configuration after every specified time period. You can also implement your own strategy.
    * ```Environment``` - Use it to specify where your configuration is located inside ConfigurationSource. It's especially useful
        when you have multiple configuration sets (e.g. multi-tenant) in one source (e.g. under different paths, on
        different git branches, etc.). Read more below.

### Configuration source
Obviously, you need your configuration to be stored somewhere before you can access it. You can store it in a K-V store (e.g. Consul K-V),
files (remote git repository, local files, classpath resources) or a relational database. If you're unsure what the best practices are,
you can consult [this article]().

Once you have your configuration in place, create a ```ConfigurationSource`` object that will fetch it. Here's an example using Consul K-V.

{% highlight java linenos=table %}
ConfigurationSource source = new ConsulConfigurationSourceBuilder().build();
{% endhighlight %}

To learn more about supported configuration sources and their capabilities head to the [PLUGINS section](#plugins).

### Configuration provider
Once we have ```ConfigurationSource``` in place, we need ```ConfigurationProvider``` that will provide your app with a uniform interface
for reading configs.

You can obtain ```ConfigurationProvider``` using builder:

{% highlight java linenos=table %}
ConfigurationSource source = ... (see above)
ConfigurationProvider provider = new ConfigurationProviderBuilder().withConfigurationSource(source).build();
{% endhighlight %}

You can also use DI container (like Spring)
{% highlight java linenos=table %}
@Bean
public ConfigurationProvider configurationProvider(ConfigurationSource source) {
  return new ConfigurationProviderBuilder().withConfigurationSource(source).build();
}
{% endhighlight %}

### Accessing configuration
Once you have ```ConfigurationProvider``` in hand you can use it for accessing configuration. Here's a bunch of examples (values that you need
to put in your configuration source are listed in comments next to examples).

* Get primitive (and boxed) types directly from Provider (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-simple)).
{% highlight java linenos=table %}
Boolean property = provider.getProperty("some.property", Boolean.class); // some.property=false

Integer property = provider.getProperty("some.other.property", Integer.class); // some.other.property=1234

float[] floats = provider.getProperty("my.floatsArray", float[].class); // my.floatsArray=1.2,99.999,0.15

URL url = provider.getProperty("my.url", URL.class); // my.url=http://www.cfg4j.org
{% endhighlight %}

* Get collections directly from Provider
{% highlight java linenos=table %}
List<String> stringList = provider.getProperty("some.string.list", new GenericType<List<String>>() {}); // some.string.list=how,are,you

Map<String, Integer> pairs = provider.getProperty("some.map", new GenericType<Map<String, Integer>>() {}); // some.map=a=1,b=33,c=-10
{% endhighlight %}

* Utilize object binding (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-bind)).
{% highlight java linenos=table %}
// Define your configuration interface
public interface MyConfiguration {
  Boolean featureToggle();
  File[] someFiles();
  Map<String, Integer> prices();
}

// someFeature.featureToggle=true
// someFeature.someFiles=/temp/fileA.txt,/temp/fileB.txt
// someFeature.prices=apple=1,candy=33,car=10
MyConfiguration config = simpleConfigurationProvider.bind("someFeature", MyConfiguration.class);

// Use it (when configuration changes your object will be auto-updated!)
if(config.featureToggle()) {
  ...
}

{% endhighlight %}


### Configuration reloading
Being able to change your configuration without bringing the service down is extremely important for web apps. **CFG4J** provides
runtime configuration reloading which can be configured using ```ReloadStrategy```. When configuration gets
reloaded all bound configuration objects (see "Accessing configuration" above) will be updated.

* Reload configuration periodically (also see [this sample app](https://github.com/cfg4j/cfg4j-sample-apps/tree/master/git-simple)).
{% highlight java linenos=table %}
// Reload every second
ConfigurationProvider provider = new ConfigurationProviderBuilder()
        .withConfigurationSource(...)
        .withReloadStrategy(new PeriodicalReloadStrategy(1, TimeUnit.SECONDS))
        .build();
{% endhighlight %}

* Reload on-demand (e.g. triggered by push mechanism)
{% highlight java linenos=table %}
// Implement your strategy
public class MyReloadStrategy implements ReloadStrategy {

  public void register(Reloadable resource) {
      ...
      resource.reload();
      ...
  }

}

ConfigurationProvider provider = new ConfigurationProviderBuilder()
        .withReloadStrategy(new MyReloadStrategy())
        .build();
{% endhighlight %}

### Multi-tenant support (a.k.a. environment selection)
You may want to store multiple configuration sets in a single configuration store (e.g. to support different environments [dev, test, prod] 
in your app or simplify because you want to maintain one store for multiple tenants).

To support this use case cfg4j introduces *Environments*. ```Environment``` is simply a way to tell the provider where in the store is your
configuration set located. Because each source may support environments differently (e.g. in git you could use separate branches or directories,
in K-V store you could use different paths, etc.).

For now we're keeping it simple. ```Environment``` has a name that is interpreted by the source. It's up to the source what interpretation
to use. Consult documentation for each of the sources (plugins) for more detail.

You can provide ```Environment``` to the provider in the following way:
{% highlight java linenos=table %}
ConfigurationProvider provider = new ConfigurationProviderBuilder()
        .withConfigurationSource(new ConsulConfigurationSourceBuilder().build())
        .withEnvironment(new ImmutableEnvironment("myApplication/prod"))  // each conf variable will be prefixed with this value when fetching from Consul
        .build();
{% endhighlight %}

### Different file types support (YAML, properties)
When reading from ```ConfigurationSource``` that is backed by files (e.g. git repository) you have an option of using either plain
**properties** files or **YAML** files. Cfg4j will automatically recognize the file by its **extension** (*.properties* or *.yaml*).

### Merging configurations from multiple sources
You can merge configs from multiple configuration sources. To do that use ```MergeConfigurationSource``` as seen below:

{% highlight java linenos=table %}
ConfigurationSource source1 = ...
ConfigurationSource source2 = ...

ConfigurationSource mergedSource = new MergeConfigurationSource(source1, source2);
{% endhighlight %}

### Fallback in case of failure
When working in a distributed environment failure happen all the time. You may consider using multiple sources. When one fails another
one will be used as a fallback. You can use ```FallbackConfigurationSource``` in the following way:

{% highlight java linenos=table %}
ConfigurationSource source1 = ...
ConfigurationSource source2 = ...

ConfigurationSource mergedSource = new FallbackConfigurationSource(source1, source2);
{% endhighlight %}

### Metrics
Most of the cfg4j components are instrumented. Metrics are exposed with support from **[Dropwizard's Metrics library](http://metrics.dropwizard.io)**.
You can see the number of invocations (e.g. how many times your configuration was reloaded) and execution time (e.g. how long does it take
to fetch configuration from external configuration source - git repository or Consul).
To enable instrumentation you have to provide ```ConfigurationProvider``` with Metric's ```MetricRegistry```. To easily differentiate
between metrics for different provided you can specify prefix prepended to all metric names constructed for the given provider.

{% highlight java linenos=table %}
@Autowired
private MetricRegistry metricRegistry;

@Bean
public ConfigurationProvider configurationProvider() {
  ...

  return new ConfigurationProviderBuilder()
      ...
      .withMetrics(metricRegistry, "firstProvider.") // Enable metrics with prefix
      .build();
}
{% endhighlight %}